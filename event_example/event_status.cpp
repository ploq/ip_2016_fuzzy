/// @file fuzz.cpp
/// @brief Generated by DEXTOOL_VERSION: v0.8.3-502-ga64b2cf
/// DO NOT EDIT THIS FILE, it will be overwritten on update.
#include "event_status.hpp"

//Event thing
struct Event {
    unsigned Event_number;
    bool Stranded;
};

namespace Foo {
    namespace Event_Status {
        namespace Provider {
	    class I_Event_Status_Impl : public I_Event_Status {
	    private:
		std::vector<std::string> clients; //Event thing
		RandomGenerator* randomGenerator;
		I_Event_Status* Other_End; //Event thing
		Event event; //Event Thing
		std::string name;
	    public:
		I_Event_Status_Impl(std::string n) {
                    randomGenerator = &TestingEnvironment::createRandomGenerator();
		    randomGenerator->generateClients(clients, 1024); //Magic number
		    name = n;
		    Other_End = 0; //to Bliex: Important, SIGSIV otherwise in Regenerate()
                }
		~I_Event_Status_Impl() {
                }

		void Regenerate() {
		    if (Other_End) {
			Get_Other_End().Event_Event(randomGenerator->generate(1, 999),
					       randomGenerator->generate(0, 1));
		    }
		}

		//Must be implemented
		void Regenerate(const std::map<std::string, std::vector<std::vector<int>>> &vars, const int64_t &curr_cycles) {
		    if (Other_End) {
			Get_Other_End().Event_Event(randomGenerator->generate(vars, "event.Event_number", 1, 999, curr_cycles), 
					       randomGenerator->generate(vars, "event.Stranded", 0, 1, curr_cycles));
		    }
		}

		bool Is_Client_Connected(std::string client_name) const {
		    /*for (auto n : clients) {
			if (n == client_name) {
			    return true;
			} 
			}
		    return false;
		    */
		    return randomGenerator->generate(0,1);
		}

		unsigned Get_Client_Id(std::string client_name) const {
		    unsigned ret = 0;
		    for (auto n : clients) {
			if (n == client_name) {
			    return ret;
			}
			ret++;
		    }
		    return -1;
		} //coherent

		const std::string Get_Client_Name(const unsigned client_id) const {
		    if (clients.size() != 0 && client_id < clients.size()
			&& client_id > 0) {
			return clients.at(client_id);
		    }
		    else {
			return "";
		    }
		} //coherent

		unsigned Get_Number_Of_Clients() const {
		    return clients.size();
		} //coherent

		void Event_Event(const unsigned event_id, const bool stranded) {
		    event.Event_number = event_id;
		    event.Stranded = stranded;
		}

		unsigned Get_Event__Bandwidth(const unsigned int client_id) const {
		    return 1;
		} //hardcoded for now

		const std::string getNamespace() {
                    return "Foo::Event_Status::Provider";
                }

		const std::string getName() {
                    return name;
                }

		std::vector<std::string> &getClients() {
                    return clients;
                }

		void Set_Other_End(I_Event_Status* other_e) {
                    Other_End = static_cast<I_Event_Status_Impl*>(other_e);
                }

		I_Event_Status & Get_Other_End() {
		    return *Other_End;
		    
                }
	    };
	    I_Event_Status::I_Event_Status() {
            }
            I_Event_Status::~I_Event_Status() {
            }
	    class I_Event_Status_Provider_Impl : public I_Event_Status_Provider {
            private:
                I_Event_Status* port;
            public:
		I_Event_Status_Provider_Impl() {
                }
		I_Event_Status_Provider_Impl(I_Event_Status* p) {
                    port = p;
                }

		//Must be implemented
		Foo::Event_Status::Provider::I_Event_Status & Get_Port() {
		    return *port;
                }

		//Needs to also generate this function, when generating Get_Port()
		Foo::Event_Status::Provider::I_Event_Status_Impl & Get_Port_Impl() {
		    return *static_cast<I_Event_Status_Impl*>(port);
                }

		void Connect_Port(Foo::Event_Status::Provider::I_Event_Status& Other_End) {
		    if (Other_End.Is_Client_Connected(Get_Port_Impl().getName())) {
			Get_Port_Impl().Set_Other_End(&Other_End);
		    }
		}
            };
            I_Event_Status_Provider::I_Event_Status_Provider() {
            }
            I_Event_Status_Provider::~I_Event_Status_Provider() {
            }
            Foo::Event_Status::Provider::I_Event_Status_Provider & Create_Instance(const std::basic_string<char> & name) {
                return PortEnvironment::createPort<I_Event_Status_Provider_Impl, I_Event_Status, I_Event_Status_Impl, const std::basic_string<char> >(name, name);
            }
        } //NS:Requirer
    } //NS:Bar
} //NS:Foo
